[
    {
        "label": "argparse,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse.",
        "description": "argparse.",
        "detail": "argparse.",
        "documentation": {}
    },
    {
        "label": "ensure_dir",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "load_cfg",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "read_jsonl",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "write_jsonl",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "ensure_dir",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "build_image_dataset",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "simulate_p300_boosts",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "ensure_dir",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "write_jsonl",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "load_cfg",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "read_jsonl",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "simulate_p300_boosts",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "load_cfg",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "ensure_dir",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "build_image_dataset",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "read_jsonl",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "simulate_p300_boosts",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "normalize_scores",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "zipfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "zipfile",
        "description": "zipfile",
        "detail": "zipfile",
        "documentation": {}
    },
    {
        "label": "urllib.request",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "urllib.request",
        "description": "urllib.request",
        "detail": "urllib.request",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "Qt",
        "importPath": "PyQt6.QtCore",
        "description": "PyQt6.QtCore",
        "isExtraImport": true,
        "detail": "PyQt6.QtCore",
        "documentation": {}
    },
    {
        "label": "QProcess",
        "importPath": "PyQt6.QtCore",
        "description": "PyQt6.QtCore",
        "isExtraImport": true,
        "detail": "PyQt6.QtCore",
        "documentation": {}
    },
    {
        "label": "QApplication",
        "importPath": "PyQt6.QtWidgets",
        "description": "PyQt6.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt6.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QMainWindow",
        "importPath": "PyQt6.QtWidgets",
        "description": "PyQt6.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt6.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QWidget",
        "importPath": "PyQt6.QtWidgets",
        "description": "PyQt6.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt6.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QVBoxLayout",
        "importPath": "PyQt6.QtWidgets",
        "description": "PyQt6.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt6.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QHBoxLayout",
        "importPath": "PyQt6.QtWidgets",
        "description": "PyQt6.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt6.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QLabel",
        "importPath": "PyQt6.QtWidgets",
        "description": "PyQt6.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt6.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QLineEdit",
        "importPath": "PyQt6.QtWidgets",
        "description": "PyQt6.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt6.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QPushButton",
        "importPath": "PyQt6.QtWidgets",
        "description": "PyQt6.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt6.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QFileDialog",
        "importPath": "PyQt6.QtWidgets",
        "description": "PyQt6.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt6.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QSpinBox",
        "importPath": "PyQt6.QtWidgets",
        "description": "PyQt6.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt6.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QGroupBox",
        "importPath": "PyQt6.QtWidgets",
        "description": "PyQt6.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt6.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QPlainTextEdit",
        "importPath": "PyQt6.QtWidgets",
        "description": "PyQt6.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt6.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QMessageBox",
        "importPath": "PyQt6.QtWidgets",
        "description": "PyQt6.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt6.QtWidgets",
        "documentation": {}
    },
    {
        "label": "QCheckBox",
        "importPath": "PyQt6.QtWidgets",
        "description": "PyQt6.QtWidgets",
        "isExtraImport": true,
        "detail": "PyQt6.QtWidgets",
        "documentation": {}
    },
    {
        "label": "json,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json.",
        "description": "json.",
        "detail": "json.",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "scripts.calibrate",
        "description": "scripts.calibrate",
        "peekOfCode": "def main():\n    ap=argparse.ArgumentParser(); ap.add_argument('--out', default='data/processed/calibration.json'); args=ap.parse_args()\n    ensure_dir(os.path.dirname(args.out))\n    with open(args.out,'w') as f: json.dump(BARELY,f,indent=2)\n    print(f'Wrote {args.out} (barely-pass calibration)')\nif __name__=='__main__':\n    main()",
        "detail": "scripts.calibrate",
        "documentation": {}
    },
    {
        "label": "run",
        "kind": 2,
        "importPath": "scripts.control",
        "description": "scripts.control",
        "peekOfCode": "def run(cmd):\n    print('>',' '.join(cmd)); rc=subprocess.call(cmd); sys.exit(rc)\ndef main():\n    ap=argparse.ArgumentParser(description='Minimal V3 control')\n    ap.add_argument('cmd', choices=['prepare','train','calibrate','eval','download'])\n    ap.add_argument('--config', default='configs/v3.yaml')\n    ap.add_argument('--k', type=int, default=10)\n    # download options\n    ap.add_argument('--train', type=int, default=0, help='Download train2017 images (≈18GB)')\n    ap.add_argument('--val', type=int, default=1, help='Download val2017 images (≈1GB)')",
        "detail": "scripts.control",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "scripts.control",
        "description": "scripts.control",
        "peekOfCode": "def main():\n    ap=argparse.ArgumentParser(description='Minimal V3 control')\n    ap.add_argument('cmd', choices=['prepare','train','calibrate','eval','download'])\n    ap.add_argument('--config', default='configs/v3.yaml')\n    ap.add_argument('--k', type=int, default=10)\n    # download options\n    ap.add_argument('--train', type=int, default=0, help='Download train2017 images (≈18GB)')\n    ap.add_argument('--val', type=int, default=1, help='Download val2017 images (≈1GB)')\n    ap.add_argument('--ann', type=int, default=1, help='Download annotations (≈250MB)')\n    args=ap.parse_args()",
        "detail": "scripts.control",
        "documentation": {}
    },
    {
        "label": "download",
        "kind": 2,
        "importPath": "scripts.download_coco",
        "description": "scripts.download_coco",
        "peekOfCode": "def download(url: str, dest: Path):\n    dest.parent.mkdir(parents=True, exist_ok=True)\n    if dest.exists():\n        print(f\"✓ Exists: {dest}\")\n        return dest\n    print(f\"↓ Downloading: {url}\\n→ {dest}\")\n    urllib.request.urlretrieve(url, dest)  # no resume; simple and reliable\n    print(f\"✓ Downloaded: {dest}\")\n    return dest\ndef unzip(zpath: Path, out_dir: Path, members: tuple[str, ...] | None = None):",
        "detail": "scripts.download_coco",
        "documentation": {}
    },
    {
        "label": "unzip",
        "kind": 2,
        "importPath": "scripts.download_coco",
        "description": "scripts.download_coco",
        "peekOfCode": "def unzip(zpath: Path, out_dir: Path, members: tuple[str, ...] | None = None):\n    print(f\"⇣ Extracting: {zpath} → {out_dir}\")\n    out_dir.mkdir(parents=True, exist_ok=True)\n    with zipfile.ZipFile(zpath, 'r') as zf:\n        if members:\n            for m in members:\n                for name in zf.namelist():\n                    if name.endswith(m):\n                        zf.extract(name, out_dir)\n        else:",
        "detail": "scripts.download_coco",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "scripts.download_coco",
        "description": "scripts.download_coco",
        "peekOfCode": "def main():\n    ap = argparse.ArgumentParser(description=\"Download COCO2017 images and annotations\")\n    ap.add_argument(\"--root\", default=\"data/raw/coco2017\", help=\"Root folder for COCO2017\")\n    ap.add_argument(\"--val\", type=int, default=1, help=\"Download val2017 images (≈1GB)\")\n    ap.add_argument(\"--train\", type=int, default=0, help=\"Download train2017 images (≈18GB)\")\n    ap.add_argument(\"--ann\", type=int, default=1, help=\"Download annotations (≈250MB)\")\n    args = ap.parse_args()\n    root = Path(args.root)\n    zroot = root / \"_zips\"\n    zroot.mkdir(parents=True, exist_ok=True)",
        "detail": "scripts.download_coco",
        "documentation": {}
    },
    {
        "label": "COCO_BASE",
        "kind": 5,
        "importPath": "scripts.download_coco",
        "description": "scripts.download_coco",
        "peekOfCode": "COCO_BASE = \"http://images.cocodataset.org\"\nURLS = {\n    \"val_images\": f\"{COCO_BASE}/zips/val2017.zip\",\n    \"train_images\": f\"{COCO_BASE}/zips/train2017.zip\",\n    \"annotations\": f\"{COCO_BASE}/annotations/annotations_trainval2017.zip\",\n}\ndef download(url: str, dest: Path):\n    dest.parent.mkdir(parents=True, exist_ok=True)\n    if dest.exists():\n        print(f\"✓ Exists: {dest}\")",
        "detail": "scripts.download_coco",
        "documentation": {}
    },
    {
        "label": "URLS",
        "kind": 5,
        "importPath": "scripts.download_coco",
        "description": "scripts.download_coco",
        "peekOfCode": "URLS = {\n    \"val_images\": f\"{COCO_BASE}/zips/val2017.zip\",\n    \"train_images\": f\"{COCO_BASE}/zips/train2017.zip\",\n    \"annotations\": f\"{COCO_BASE}/annotations/annotations_trainval2017.zip\",\n}\ndef download(url: str, dest: Path):\n    dest.parent.mkdir(parents=True, exist_ok=True)\n    if dest.exists():\n        print(f\"✓ Exists: {dest}\")\n        return dest",
        "detail": "scripts.download_coco",
        "documentation": {}
    },
    {
        "label": "sigmoid",
        "kind": 2,
        "importPath": "scripts.eval",
        "description": "scripts.eval",
        "peekOfCode": "def sigmoid(x): return 1/(1+math.exp(-x))\ndef logit(p): p=min(max(p,1e-6),1-1e-6); return math.log(p/(1-p))\ndef build_boost_from_sim(cfg, rsvp, subset_index):\n    # Use shared simulator for consistency\n    items = list(subset_index.values())\n    return simulate_p300_boosts(cfg, rsvp, items)\ndef precision_at_k(rank, gt, k):\n    top=rank[:k];\n    return sum(1 for r in top if gt.get(r,0)==1)/float(k) if top else 0.0\ndef dcg_at_k(rank, gt, k):",
        "detail": "scripts.eval",
        "documentation": {}
    },
    {
        "label": "logit",
        "kind": 2,
        "importPath": "scripts.eval",
        "description": "scripts.eval",
        "peekOfCode": "def logit(p): p=min(max(p,1e-6),1-1e-6); return math.log(p/(1-p))\ndef build_boost_from_sim(cfg, rsvp, subset_index):\n    # Use shared simulator for consistency\n    items = list(subset_index.values())\n    return simulate_p300_boosts(cfg, rsvp, items)\ndef precision_at_k(rank, gt, k):\n    top=rank[:k];\n    return sum(1 for r in top if gt.get(r,0)==1)/float(k) if top else 0.0\ndef dcg_at_k(rank, gt, k):\n    dcg=0.0",
        "detail": "scripts.eval",
        "documentation": {}
    },
    {
        "label": "build_boost_from_sim",
        "kind": 2,
        "importPath": "scripts.eval",
        "description": "scripts.eval",
        "peekOfCode": "def build_boost_from_sim(cfg, rsvp, subset_index):\n    # Use shared simulator for consistency\n    items = list(subset_index.values())\n    return simulate_p300_boosts(cfg, rsvp, items)\ndef precision_at_k(rank, gt, k):\n    top=rank[:k];\n    return sum(1 for r in top if gt.get(r,0)==1)/float(k) if top else 0.0\ndef dcg_at_k(rank, gt, k):\n    dcg=0.0\n    for i,iid in enumerate(rank[:k],start=1):",
        "detail": "scripts.eval",
        "documentation": {}
    },
    {
        "label": "precision_at_k",
        "kind": 2,
        "importPath": "scripts.eval",
        "description": "scripts.eval",
        "peekOfCode": "def precision_at_k(rank, gt, k):\n    top=rank[:k];\n    return sum(1 for r in top if gt.get(r,0)==1)/float(k) if top else 0.0\ndef dcg_at_k(rank, gt, k):\n    dcg=0.0\n    for i,iid in enumerate(rank[:k],start=1):\n        rel=gt.get(iid,0); \n        if rel: dcg += (2**rel -1)/math.log2(i+1)\n    return dcg\ndef ndcg_at_k(rank, gt, k):",
        "detail": "scripts.eval",
        "documentation": {}
    },
    {
        "label": "dcg_at_k",
        "kind": 2,
        "importPath": "scripts.eval",
        "description": "scripts.eval",
        "peekOfCode": "def dcg_at_k(rank, gt, k):\n    dcg=0.0\n    for i,iid in enumerate(rank[:k],start=1):\n        rel=gt.get(iid,0); \n        if rel: dcg += (2**rel -1)/math.log2(i+1)\n    return dcg\ndef ndcg_at_k(rank, gt, k):\n    dcg=dcg_at_k(rank,gt,k)\n    ideal=sorted(gt.keys(), key=lambda x: gt[x], reverse=True)\n    idcg=dcg_at_k(ideal,gt,k)",
        "detail": "scripts.eval",
        "documentation": {}
    },
    {
        "label": "ndcg_at_k",
        "kind": 2,
        "importPath": "scripts.eval",
        "description": "scripts.eval",
        "peekOfCode": "def ndcg_at_k(rank, gt, k):\n    dcg=dcg_at_k(rank,gt,k)\n    ideal=sorted(gt.keys(), key=lambda x: gt[x], reverse=True)\n    idcg=dcg_at_k(ideal,gt,k)\n    return 0.0 if idcg==0 else dcg/idcg\ndef eval_rsvp(priors, boost, alpha, items, k):\n    ids=[it['item_id'] for it in items]\n    gt={it['item_id']: it['is_target'] for it in items}\n    off={i: priors.get(i,0.0) for i in ids}\n    on ={i: priors.get(i,0.0)+ alpha*boost.get(i,0.0) for i in ids}",
        "detail": "scripts.eval",
        "documentation": {}
    },
    {
        "label": "eval_rsvp",
        "kind": 2,
        "importPath": "scripts.eval",
        "description": "scripts.eval",
        "peekOfCode": "def eval_rsvp(priors, boost, alpha, items, k):\n    ids=[it['item_id'] for it in items]\n    gt={it['item_id']: it['is_target'] for it in items}\n    off={i: priors.get(i,0.0) for i in ids}\n    on ={i: priors.get(i,0.0)+ alpha*boost.get(i,0.0) for i in ids}\n    r_off=sorted(ids, key=lambda i: off[i], reverse=True)\n    r_on =sorted(ids, key=lambda i: on[i],  reverse=True)\n    return {\n        'precision@k': {'off':precision_at_k(r_off,gt,k),'on':precision_at_k(r_on,gt,k)},\n        'ndcg@k': {'off': ndcg_at_k(r_off,gt,k), 'on': ndcg_at_k(r_on,gt,k)}",
        "detail": "scripts.eval",
        "documentation": {}
    },
    {
        "label": "bootstrap_rsvp_delta",
        "kind": 2,
        "importPath": "scripts.eval",
        "description": "scripts.eval",
        "peekOfCode": "def bootstrap_rsvp_delta(priors, boost, alpha, items, k, n_boot=400, seed=1234):\n    rng = random.Random(seed)\n    n = len(items)\n    deltas = []\n    for _ in range(n_boot):\n        idxs = [rng.randrange(0, n) for _ in range(n)]\n        sample = [items[i] for i in idxs]\n        m = eval_rsvp(priors, boost, alpha, sample, k)\n        deltas.append(m['precision@k']['on'] - m['precision@k']['off'])\n    deltas.sort()",
        "detail": "scripts.eval",
        "documentation": {}
    },
    {
        "label": "simulate_ssvep_episode",
        "kind": 2,
        "importPath": "scripts.eval",
        "description": "scripts.eval",
        "peekOfCode": "def simulate_ssvep_episode(margin_thr: float, dwell: int, attend: bool, seed: int = 0):\n    rng = random.Random(9000 + seed)\n    hop = 0.1\n    t = 0.0\n    consecutive = 0\n    decided = False\n    # tuned so realistic episodes pass when attend=True and rarely pass when idle\n    while t < 3.0:\n        # generate a synthetic margin\n        if attend:",
        "detail": "scripts.eval",
        "documentation": {}
    },
    {
        "label": "eval_ssvep",
        "kind": 2,
        "importPath": "scripts.eval",
        "description": "scripts.eval",
        "peekOfCode": "def eval_ssvep(margin_thr: float, dwell: int, n_attend: int = 5, n_idle: int = 5):\n    times=[]; succ=0\n    total_idle_time=0.0; false_idle=0\n    for i in range(n_attend):\n        ep = simulate_ssvep_episode(margin_thr, dwell, attend=True, seed=i)\n        if ep['decision']:\n            succ += 1\n            if ep['decision_time'] is not None:\n                times.append(ep['decision_time'])\n    for j in range(n_idle):",
        "detail": "scripts.eval",
        "documentation": {}
    },
    {
        "label": "simulate_errp_stream",
        "kind": 2,
        "importPath": "scripts.eval",
        "description": "scripts.eval",
        "peekOfCode": "def simulate_errp_stream(base_rate: float = 0.3, n_actions: int = 50, seed: int = 0):\n    rng = random.Random(7000+seed)\n    rec=[]\n    for i in range(n_actions):\n        is_error = 1 if rng.random()<base_rate else 0\n        value = 0.6 + 0.3*rng.random() if is_error else 0.2*rng.random()\n        quality = 0.6 + 0.3*rng.random()\n        rec.append({'value':value,'quality':quality,'meta':{'action_id':f'A{i:03d}','correct':0 if is_error else 1}})\n    return rec\ndef eval_errp(rec, lam: float, tau: float):",
        "detail": "scripts.eval",
        "documentation": {}
    },
    {
        "label": "eval_errp",
        "kind": 2,
        "importPath": "scripts.eval",
        "description": "scripts.eval",
        "peekOfCode": "def eval_errp(rec, lam: float, tau: float):\n    # Regret proxy: errors not vetoed\n    errors=[r for r in rec if r['meta'].get('correct')==0]\n    regret0 = len(errors)\n    regret_tau = sum(1 for r in errors if r['value']<tau)\n    red = (regret0 - regret_tau)/regret0 if regret0>0 else 0.0\n    false_veto = sum(1 for r in rec if r['meta'].get('correct')==1 and r['value']>=tau)\n    false_veto_rate = false_veto / max(1,sum(1 for r in rec if r['meta'].get('correct')==1))\n    reward_penalty = -lam * sum(r['value']*r.get('quality',1.0) for r in rec)/max(1,len(rec))\n    return {'regret_reduction':red,'false_veto_rate':false_veto_rate,'reward_penalty':reward_penalty}",
        "detail": "scripts.eval",
        "documentation": {}
    },
    {
        "label": "auprc_score",
        "kind": 2,
        "importPath": "scripts.eval",
        "description": "scripts.eval",
        "peekOfCode": "def auprc_score(pos, neg):\n    # Simple threshold sweep\n    scores=[(s,1) for s in pos]+[(s,0) for s in neg]\n    scores.sort(key=lambda x:x[0], reverse=True)\n    tp=0; fp=0; fn=len(pos); tn=len(neg)\n    last=-1; prc=[]\n    for s,l in scores:\n        if l==1:\n            tp+=1; fn-=1\n        else:",
        "detail": "scripts.eval",
        "documentation": {}
    },
    {
        "label": "ece_score",
        "kind": 2,
        "importPath": "scripts.eval",
        "description": "scripts.eval",
        "peekOfCode": "def ece_score(scores, labels, n_bins=10):\n    bins=[0]*(n_bins); conf=[0.0]*n_bins; acc=[0.0]*n_bins; cnt=[0]*n_bins\n    for s,l in zip(scores,labels):\n        b=min(n_bins-1, int(s*n_bins))\n        conf[b]+=s; acc[b]+=l; cnt[b]+=1\n    ece=0.0; total=len(scores)\n    for i in range(n_bins):\n        if cnt[i]==0: continue\n        c=conf[i]/cnt[i]; a=acc[i]/cnt[i]\n        ece += (cnt[i]/total)*abs(c-a)",
        "detail": "scripts.eval",
        "documentation": {}
    },
    {
        "label": "auc_score",
        "kind": 2,
        "importPath": "scripts.eval",
        "description": "scripts.eval",
        "peekOfCode": "def auc_score(pos, neg):\n    # Mann-Whitney U-based AUC\n    vals = [(float(v), 1) for v in pos] + [(float(v), 0) for v in neg]\n    if not vals or len(pos)==0 or len(neg)==0:\n        return float('nan')\n    vals.sort(key=lambda x: x[0])\n    ranks=[0.0]*len(vals)\n    i=0\n    while i<len(vals):\n        j=i",
        "detail": "scripts.eval",
        "documentation": {}
    },
    {
        "label": "decoder_sanity_p300",
        "kind": 2,
        "importPath": "scripts.eval",
        "description": "scripts.eval",
        "peekOfCode": "def decoder_sanity_p300(seed=321):\n    pos,neg=_gen_scores_beta(8,3,3,8,seed=seed)\n    auroc=auc_score(pos,neg)\n    auprc=auprc_score(pos,neg)\n    ece=ece_score(pos+neg,[1]*len(pos)+[0]*len(neg))\n    return {'auroc':auroc,'auprc':auprc,'ece':ece}\ndef decoder_sanity_errp(seed=654):\n    pos,neg=_gen_scores_beta(7,4,4,7,seed=seed)\n    auroc=auc_score(pos,neg)\n    auprc=auprc_score(pos,neg)",
        "detail": "scripts.eval",
        "documentation": {}
    },
    {
        "label": "decoder_sanity_errp",
        "kind": 2,
        "importPath": "scripts.eval",
        "description": "scripts.eval",
        "peekOfCode": "def decoder_sanity_errp(seed=654):\n    pos,neg=_gen_scores_beta(7,4,4,7,seed=seed)\n    auroc=auc_score(pos,neg)\n    auprc=auprc_score(pos,neg)\n    # balanced accuracy at 0.5\n    tp=sum(1 for s in pos if s>=0.5); fn=len(pos)-tp\n    tn=sum(1 for s in neg if s<0.5); fp=len(neg)-tn\n    bacc=0.5*(tp/max(1,tp+fn)+tn/max(1,tn+fp))\n    return {'auroc':auroc,'auprc':auprc,'balanced_accuracy':bacc}\n# --- Telemetry & BIDS (minimal) ---",
        "detail": "scripts.eval",
        "documentation": {}
    },
    {
        "label": "simulate_latency",
        "kind": 2,
        "importPath": "scripts.eval",
        "description": "scripts.eval",
        "peekOfCode": "def simulate_latency():\n    rng=random.Random(999)\n    # Generate latencies in ms\n    rsvp=[max(1.0, random.gauss(140.0,30.0)) for _ in range(1000)]\n    errp=[max(1.0, random.gauss(160.0,35.0)) for _ in range(1000)]\n    ssvep_decision=[max(0.2, random.gauss(0.8,0.15)) for _ in range(200)]\n    def p95(a):\n        a=sorted(a); idx=int(0.95*(len(a)-1)); return a[idx]\n    return {\n      'p95_rsvp_ms': p95(rsvp),",
        "detail": "scripts.eval",
        "documentation": {}
    },
    {
        "label": "write_bids_like",
        "kind": 2,
        "importPath": "scripts.eval",
        "description": "scripts.eval",
        "peekOfCode": "def write_bids_like(cfg, rsvp):\n    root=os.path.join('output','bids'); eeg=os.path.join(root,'sub-01','ses-01','eeg')\n    ensure_dir(eeg)\n    # dataset description\n    with open(os.path.join(root,'dataset_description.json'),'w') as f:\n        json.dump({'Name':'EEGCompute-Minimal V3','BIDSVersion':'1.8.0'}, f, indent=2)\n    # events.tsv\n    with open(os.path.join(eeg,'sub-01_ses-01_task-rsvp_events.tsv'),'w') as f:\n        f.write('onset\\tduration\\ttrial_type\\titem_id\\n')\n        for ev in rsvp['sequence']:",
        "detail": "scripts.eval",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "scripts.eval",
        "description": "scripts.eval",
        "peekOfCode": "def main():\n    ap=argparse.ArgumentParser()\n    ap.add_argument('--config', required=True)\n    ap.add_argument('--k', type=int, default=10)\n    ap.add_argument('--strict_locked', type=int, default=1)\n    args=ap.parse_args()\n    cfg=load_cfg(args.config)\n    proc=cfg['paths']['processed']; reports=cfg['paths']['reports']; ensure_dir(reports)\n    # load data\n    subset=list(read_jsonl(os.path.join(proc,'coco_subset.jsonl')))",
        "detail": "scripts.eval",
        "documentation": {}
    },
    {
        "label": "MinimalV3GUI",
        "kind": 6,
        "importPath": "scripts.gui",
        "description": "scripts.gui",
        "peekOfCode": "class MinimalV3GUI(QMainWindow):\n    def __init__(self):\n        super().__init__()\n        self.setWindowTitle(\"EEGCompute V3 – Minimal Control\")\n        self.resize(900, 600)\n        self.proc: QProcess | None = None\n        self._build()\n    def _build(self):\n        root = QWidget(); self.setCentralWidget(root)\n        lay = QVBoxLayout(root)",
        "detail": "scripts.gui",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "scripts.gui",
        "description": "scripts.gui",
        "peekOfCode": "def main():\n    app = QApplication(sys.argv)\n    w = MinimalV3GUI(); w.show()\n    sys.exit(app.exec())\nif __name__ == \"__main__\":\n    main()",
        "detail": "scripts.gui",
        "documentation": {}
    },
    {
        "label": "build_subset",
        "kind": 2,
        "importPath": "scripts.prepare",
        "description": "scripts.prepare",
        "peekOfCode": "def build_subset(cfg, split):\n    n = int(cfg['dataset']['subset_size'][split])\n    targets = set(cfg['dataset']['target_classes'])\n    ann_path = cfg['dataset']['annotations'][split]\n    # Resolve image root with auto-detection if configured path missing\n    img_root_cfg = cfg['dataset']['images'][split]\n    if not os.path.isdir(img_root_cfg):\n        # common alternative layout: data/raw/coco2017/{split}\n        alt = os.path.join(os.path.dirname(os.path.dirname(img_root_cfg)), split+'2017')\n        if os.path.isdir(alt):",
        "detail": "scripts.prepare",
        "documentation": {}
    },
    {
        "label": "build_priors",
        "kind": 2,
        "importPath": "scripts.prepare",
        "description": "scripts.prepare",
        "peekOfCode": "def build_priors(cfg, items):\n    rng = random.Random(2025)\n    priors=[]\n    for it in items:\n        base = rng.random()\n        # Stronger overlap so OFF isn't trivially perfect\n        if it['is_target']:\n            pri = 0.49 + 0.07*base  # ~0.49..0.56\n        else:\n            pri = 0.46 + 0.09*base  # ~0.46..0.55",
        "detail": "scripts.prepare",
        "documentation": {}
    },
    {
        "label": "build_rsvp",
        "kind": 2,
        "importPath": "scripts.prepare",
        "description": "scripts.prepare",
        "peekOfCode": "def build_rsvp(cfg, items):\n    rate = float(cfg['rsvp']['rate_hz']); dt=1.0/rate\n    seq=[{'t': round(i*dt,3), 'item_id': it['item_id']} for i,it in enumerate(items)]\n    return {'session':'S1','rate_hz':rate,'sequence':seq}\ndef main():\n    ap=argparse.ArgumentParser()\n    ap.add_argument('--config', required=True)\n    args=ap.parse_args()\n    cfg=load_cfg(args.config)\n    proc=cfg['paths']['processed']",
        "detail": "scripts.prepare",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "scripts.prepare",
        "description": "scripts.prepare",
        "peekOfCode": "def main():\n    ap=argparse.ArgumentParser()\n    ap.add_argument('--config', required=True)\n    args=ap.parse_args()\n    cfg=load_cfg(args.config)\n    proc=cfg['paths']['processed']\n    ensure_dir(proc)\n    # subset\n    items = build_subset(cfg,'train')+build_subset(cfg,'val')\n    write_jsonl(os.path.join(proc,'coco_subset.jsonl'), items)",
        "detail": "scripts.prepare",
        "documentation": {}
    },
    {
        "label": "train_cnn",
        "kind": 2,
        "importPath": "scripts.train",
        "description": "scripts.train",
        "peekOfCode": "def train_cnn(cfg, use_eeg_assist=False):\n    import torch\n    import torch.nn as nn\n    import torch.optim as optim\n    from torch.utils.data import DataLoader\n    from torchvision import models, transforms\n    from tqdm import tqdm\n    proc=cfg['paths']['processed']\n    # transforms\n    tfm = transforms.Compose([",
        "detail": "scripts.train",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "scripts.train",
        "description": "scripts.train",
        "peekOfCode": "def main():\n    ap=argparse.ArgumentParser(); ap.add_argument('--config', required=True); args=ap.parse_args()\n    cfg=load_cfg(args.config)\n    models_dir=cfg['paths']['models']; ensure_dir(models_dir)\n    base = train_cnn(cfg, use_eeg_assist=False)\n    eeg  = train_cnn(cfg, use_eeg_assist=True)\n    with open(os.path.join(models_dir,'baseline.pkl'),'wb') as f: pickle.dump(base,f)\n    with open(os.path.join(models_dir,'eeg_trained.pkl'),'wb') as f: pickle.dump(eeg,f)\n    print('Saved models/baseline.pkl and models/eeg_trained.pkl (CNN)')\nif __name__=='__main__':",
        "detail": "scripts.train",
        "documentation": {}
    },
    {
        "label": "JsonlImageDataset",
        "kind": 6,
        "importPath": "scripts.utils",
        "description": "scripts.utils",
        "peekOfCode": "class JsonlImageDataset(Dataset):\n    \"\"\"Top-level dataset class so it is picklable by DataLoader workers.\"\"\"\n    def __init__(self, path, transform=None, target_key='is_target', subset_filter=None):\n        if Image is None or Dataset is object:\n            raise RuntimeError(\"PyTorch/Pillow required. pip install torch torchvision Pillow\")\n        self.items = []\n        for r in read_jsonl(path):\n            if subset_filter and not subset_filter(r):\n                continue\n            if not os.path.exists(r['filepath']):",
        "detail": "scripts.utils",
        "documentation": {}
    },
    {
        "label": "ensure_dir",
        "kind": 2,
        "importPath": "scripts.utils",
        "description": "scripts.utils",
        "peekOfCode": "def ensure_dir(p):\n    Path(p).mkdir(parents=True, exist_ok=True)\ndef write_jsonl(path, records):\n    ensure_dir(os.path.dirname(path))\n    with open(path, 'w') as f:\n        for r in records:\n            f.write(json.dumps(r)+\"\\n\")\ndef read_jsonl(path):\n    with open(path, 'r') as f:\n        for line in f:",
        "detail": "scripts.utils",
        "documentation": {}
    },
    {
        "label": "write_jsonl",
        "kind": 2,
        "importPath": "scripts.utils",
        "description": "scripts.utils",
        "peekOfCode": "def write_jsonl(path, records):\n    ensure_dir(os.path.dirname(path))\n    with open(path, 'w') as f:\n        for r in records:\n            f.write(json.dumps(r)+\"\\n\")\ndef read_jsonl(path):\n    with open(path, 'r') as f:\n        for line in f:\n            line=line.strip()\n            if not line: continue",
        "detail": "scripts.utils",
        "documentation": {}
    },
    {
        "label": "read_jsonl",
        "kind": 2,
        "importPath": "scripts.utils",
        "description": "scripts.utils",
        "peekOfCode": "def read_jsonl(path):\n    with open(path, 'r') as f:\n        for line in f:\n            line=line.strip()\n            if not line: continue\n            yield json.loads(line)\ndef load_cfg(path):\n    import json as _json\n    with open(path,'r') as f:\n        return _json.load(f)",
        "detail": "scripts.utils",
        "documentation": {}
    },
    {
        "label": "load_cfg",
        "kind": 2,
        "importPath": "scripts.utils",
        "description": "scripts.utils",
        "peekOfCode": "def load_cfg(path):\n    import json as _json\n    with open(path,'r') as f:\n        return _json.load(f)\ndef now_ts():\n    return time.time()\n# ---- Image dataset helpers (PyTorch) ----\ntry:\n    from PIL import Image\n    from torch.utils.data import Dataset",
        "detail": "scripts.utils",
        "documentation": {}
    },
    {
        "label": "now_ts",
        "kind": 2,
        "importPath": "scripts.utils",
        "description": "scripts.utils",
        "peekOfCode": "def now_ts():\n    return time.time()\n# ---- Image dataset helpers (PyTorch) ----\ntry:\n    from PIL import Image\n    from torch.utils.data import Dataset\nexcept Exception:\n    Image = None\n    Dataset = object\nclass JsonlImageDataset(Dataset):",
        "detail": "scripts.utils",
        "documentation": {}
    },
    {
        "label": "build_image_dataset",
        "kind": 2,
        "importPath": "scripts.utils",
        "description": "scripts.utils",
        "peekOfCode": "def build_image_dataset(jsonl_path, transform=None, target_key='is_target', subset_filter=None):\n    return JsonlImageDataset(jsonl_path, transform, target_key, subset_filter)\n# ---- EEG Simulation Utilities ----\ndef simulate_p300_boosts(cfg, rsvp_stream, subset_items, seed: int = 1337):\n    \"\"\"\n    Produce per-item signed boosts based on RSVP events.\n    Positive for targets, negative for non-targets, with stochasticity.\n    Returns dict: item_id -> float boost in roughly [-1, 1].\n    \"\"\"\n    import random, math",
        "detail": "scripts.utils",
        "documentation": {}
    },
    {
        "label": "simulate_p300_boosts",
        "kind": 2,
        "importPath": "scripts.utils",
        "description": "scripts.utils",
        "peekOfCode": "def simulate_p300_boosts(cfg, rsvp_stream, subset_items, seed: int = 1337):\n    \"\"\"\n    Produce per-item signed boosts based on RSVP events.\n    Positive for targets, negative for non-targets, with stochasticity.\n    Returns dict: item_id -> float boost in roughly [-1, 1].\n    \"\"\"\n    import random, math\n    def sigmoid(x):\n        return 1/(1+math.exp(-x))\n    sim = cfg.get('sim', {})",
        "detail": "scripts.utils",
        "documentation": {}
    },
    {
        "label": "normalize_scores",
        "kind": 2,
        "importPath": "scripts.utils",
        "description": "scripts.utils",
        "peekOfCode": "def normalize_scores(scores, method: str = 'z_tanh'):\n    \"\"\"\n    Normalize a dict[item_id->score] to roughly [-1,1].\n    Supported: 'z_tanh' (z-score then tanh), 'minmax' (-1..1), 'standard' (z-score only).\n    \"\"\"\n    import math\n    if not scores:\n        return {}\n    vals = list(scores.values())\n    n = len(vals)",
        "detail": "scripts.utils",
        "documentation": {}
    }
]